// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package pool

//go:generate minimock -i net.Conn -o zzz_net_conn_mock_test.go -n ConnMock -p pool

import (
	mm_net "net"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"
	_ "unsafe"

	"github.com/gojuno/minimock/v3"
)

// ConnMock implements mm_net.Conn
type ConnMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mConnMockClose

	funcLocalAddr          func() (a1 mm_net.Addr)
	funcLocalAddrOrigin    string
	inspectFuncLocalAddr   func()
	afterLocalAddrCounter  uint64
	beforeLocalAddrCounter uint64
	LocalAddrMock          mConnMockLocalAddr

	funcRead          func(b []byte) (n int, err error)
	funcReadOrigin    string
	inspectFuncRead   func(b []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mConnMockRead

	funcRemoteAddr          func() (a1 mm_net.Addr)
	funcRemoteAddrOrigin    string
	inspectFuncRemoteAddr   func()
	afterRemoteAddrCounter  uint64
	beforeRemoteAddrCounter uint64
	RemoteAddrMock          mConnMockRemoteAddr

	funcSetDeadline          func(t time.Time) (err error)
	funcSetDeadlineOrigin    string
	inspectFuncSetDeadline   func(t time.Time)
	afterSetDeadlineCounter  uint64
	beforeSetDeadlineCounter uint64
	SetDeadlineMock          mConnMockSetDeadline

	funcSetReadDeadline          func(t time.Time) (err error)
	funcSetReadDeadlineOrigin    string
	inspectFuncSetReadDeadline   func(t time.Time)
	afterSetReadDeadlineCounter  uint64
	beforeSetReadDeadlineCounter uint64
	SetReadDeadlineMock          mConnMockSetReadDeadline

	funcSetWriteDeadline          func(t time.Time) (err error)
	funcSetWriteDeadlineOrigin    string
	inspectFuncSetWriteDeadline   func(t time.Time)
	afterSetWriteDeadlineCounter  uint64
	beforeSetWriteDeadlineCounter uint64
	SetWriteDeadlineMock          mConnMockSetWriteDeadline

	funcWrite          func(b []byte) (n int, err error)
	funcWriteOrigin    string
	inspectFuncWrite   func(b []byte)
	afterWriteCounter  uint64
	beforeWriteCounter uint64
	WriteMock          mConnMockWrite
}

// NewConnMock returns a mock for mm_net.Conn
func NewConnMock(t minimock.Tester) *ConnMock {
	m := &ConnMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mConnMockClose{mock: m}

	m.LocalAddrMock = mConnMockLocalAddr{mock: m}

	m.ReadMock = mConnMockRead{mock: m}
	m.ReadMock.callArgs = []*ConnMockReadParams{}

	m.RemoteAddrMock = mConnMockRemoteAddr{mock: m}

	m.SetDeadlineMock = mConnMockSetDeadline{mock: m}
	m.SetDeadlineMock.callArgs = []*ConnMockSetDeadlineParams{}

	m.SetReadDeadlineMock = mConnMockSetReadDeadline{mock: m}
	m.SetReadDeadlineMock.callArgs = []*ConnMockSetReadDeadlineParams{}

	m.SetWriteDeadlineMock = mConnMockSetWriteDeadline{mock: m}
	m.SetWriteDeadlineMock.callArgs = []*ConnMockSetWriteDeadlineParams{}

	m.WriteMock = mConnMockWrite{mock: m}
	m.WriteMock.callArgs = []*ConnMockWriteParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mConnMockClose struct {
	optional           bool
	mock               *ConnMock
	defaultExpectation *ConnMockCloseExpectation
	expectations       []*ConnMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnMockCloseExpectation specifies expectation struct of the Conn.Close
type ConnMockCloseExpectation struct {
	mock *ConnMock

	results      *ConnMockCloseResults
	returnOrigin string
	Counter      uint64
}

// ConnMockCloseResults contains results of the Conn.Close
type ConnMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mConnMockClose) Optional() *mConnMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Conn.Close
func (mmClose *mConnMockClose) Expect() *mConnMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ConnMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ConnMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Conn.Close
func (mmClose *mConnMockClose) Inspect(f func()) *mConnMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ConnMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Conn.Close
func (mmClose *mConnMockClose) Return(err error) *ConnMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ConnMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ConnMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ConnMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Conn.Close method
func (mmClose *mConnMockClose) Set(f func() (err error)) *ConnMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Conn.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Conn.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Conn.Close should be invoked
func (mmClose *mConnMockClose) Times(n uint64) *mConnMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of ConnMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mConnMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_net.Conn
func (mmClose *ConnMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ConnMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ConnMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ConnMock.Close invocations
func (mmClose *ConnMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ConnMock.Close invocations
func (mmClose *ConnMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *ConnMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ConnMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ConnMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mConnMockLocalAddr struct {
	optional           bool
	mock               *ConnMock
	defaultExpectation *ConnMockLocalAddrExpectation
	expectations       []*ConnMockLocalAddrExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnMockLocalAddrExpectation specifies expectation struct of the Conn.LocalAddr
type ConnMockLocalAddrExpectation struct {
	mock *ConnMock

	results      *ConnMockLocalAddrResults
	returnOrigin string
	Counter      uint64
}

// ConnMockLocalAddrResults contains results of the Conn.LocalAddr
type ConnMockLocalAddrResults struct {
	a1 mm_net.Addr
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLocalAddr *mConnMockLocalAddr) Optional() *mConnMockLocalAddr {
	mmLocalAddr.optional = true
	return mmLocalAddr
}

// Expect sets up expected params for Conn.LocalAddr
func (mmLocalAddr *mConnMockLocalAddr) Expect() *mConnMockLocalAddr {
	if mmLocalAddr.mock.funcLocalAddr != nil {
		mmLocalAddr.mock.t.Fatalf("ConnMock.LocalAddr mock is already set by Set")
	}

	if mmLocalAddr.defaultExpectation == nil {
		mmLocalAddr.defaultExpectation = &ConnMockLocalAddrExpectation{}
	}

	return mmLocalAddr
}

// Inspect accepts an inspector function that has same arguments as the Conn.LocalAddr
func (mmLocalAddr *mConnMockLocalAddr) Inspect(f func()) *mConnMockLocalAddr {
	if mmLocalAddr.mock.inspectFuncLocalAddr != nil {
		mmLocalAddr.mock.t.Fatalf("Inspect function is already set for ConnMock.LocalAddr")
	}

	mmLocalAddr.mock.inspectFuncLocalAddr = f

	return mmLocalAddr
}

// Return sets up results that will be returned by Conn.LocalAddr
func (mmLocalAddr *mConnMockLocalAddr) Return(a1 mm_net.Addr) *ConnMock {
	if mmLocalAddr.mock.funcLocalAddr != nil {
		mmLocalAddr.mock.t.Fatalf("ConnMock.LocalAddr mock is already set by Set")
	}

	if mmLocalAddr.defaultExpectation == nil {
		mmLocalAddr.defaultExpectation = &ConnMockLocalAddrExpectation{mock: mmLocalAddr.mock}
	}
	mmLocalAddr.defaultExpectation.results = &ConnMockLocalAddrResults{a1}
	mmLocalAddr.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLocalAddr.mock
}

// Set uses given function f to mock the Conn.LocalAddr method
func (mmLocalAddr *mConnMockLocalAddr) Set(f func() (a1 mm_net.Addr)) *ConnMock {
	if mmLocalAddr.defaultExpectation != nil {
		mmLocalAddr.mock.t.Fatalf("Default expectation is already set for the Conn.LocalAddr method")
	}

	if len(mmLocalAddr.expectations) > 0 {
		mmLocalAddr.mock.t.Fatalf("Some expectations are already set for the Conn.LocalAddr method")
	}

	mmLocalAddr.mock.funcLocalAddr = f
	mmLocalAddr.mock.funcLocalAddrOrigin = minimock.CallerInfo(1)
	return mmLocalAddr.mock
}

// Times sets number of times Conn.LocalAddr should be invoked
func (mmLocalAddr *mConnMockLocalAddr) Times(n uint64) *mConnMockLocalAddr {
	if n == 0 {
		mmLocalAddr.mock.t.Fatalf("Times of ConnMock.LocalAddr mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLocalAddr.expectedInvocations, n)
	mmLocalAddr.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLocalAddr
}

func (mmLocalAddr *mConnMockLocalAddr) invocationsDone() bool {
	if len(mmLocalAddr.expectations) == 0 && mmLocalAddr.defaultExpectation == nil && mmLocalAddr.mock.funcLocalAddr == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLocalAddr.mock.afterLocalAddrCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLocalAddr.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LocalAddr implements mm_net.Conn
func (mmLocalAddr *ConnMock) LocalAddr() (a1 mm_net.Addr) {
	mm_atomic.AddUint64(&mmLocalAddr.beforeLocalAddrCounter, 1)
	defer mm_atomic.AddUint64(&mmLocalAddr.afterLocalAddrCounter, 1)

	mmLocalAddr.t.Helper()

	if mmLocalAddr.inspectFuncLocalAddr != nil {
		mmLocalAddr.inspectFuncLocalAddr()
	}

	if mmLocalAddr.LocalAddrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLocalAddr.LocalAddrMock.defaultExpectation.Counter, 1)

		mm_results := mmLocalAddr.LocalAddrMock.defaultExpectation.results
		if mm_results == nil {
			mmLocalAddr.t.Fatal("No results are set for the ConnMock.LocalAddr")
		}
		return (*mm_results).a1
	}
	if mmLocalAddr.funcLocalAddr != nil {
		return mmLocalAddr.funcLocalAddr()
	}
	mmLocalAddr.t.Fatalf("Unexpected call to ConnMock.LocalAddr.")
	return
}

// LocalAddrAfterCounter returns a count of finished ConnMock.LocalAddr invocations
func (mmLocalAddr *ConnMock) LocalAddrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLocalAddr.afterLocalAddrCounter)
}

// LocalAddrBeforeCounter returns a count of ConnMock.LocalAddr invocations
func (mmLocalAddr *ConnMock) LocalAddrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLocalAddr.beforeLocalAddrCounter)
}

// MinimockLocalAddrDone returns true if the count of the LocalAddr invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockLocalAddrDone() bool {
	if m.LocalAddrMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LocalAddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LocalAddrMock.invocationsDone()
}

// MinimockLocalAddrInspect logs each unmet expectation
func (m *ConnMock) MinimockLocalAddrInspect() {
	for _, e := range m.LocalAddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnMock.LocalAddr")
		}
	}

	afterLocalAddrCounter := mm_atomic.LoadUint64(&m.afterLocalAddrCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LocalAddrMock.defaultExpectation != nil && afterLocalAddrCounter < 1 {
		m.t.Errorf("Expected call to ConnMock.LocalAddr at\n%s", m.LocalAddrMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLocalAddr != nil && afterLocalAddrCounter < 1 {
		m.t.Errorf("Expected call to ConnMock.LocalAddr at\n%s", m.funcLocalAddrOrigin)
	}

	if !m.LocalAddrMock.invocationsDone() && afterLocalAddrCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnMock.LocalAddr at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LocalAddrMock.expectedInvocations), m.LocalAddrMock.expectedInvocationsOrigin, afterLocalAddrCounter)
	}
}

type mConnMockRead struct {
	optional           bool
	mock               *ConnMock
	defaultExpectation *ConnMockReadExpectation
	expectations       []*ConnMockReadExpectation

	callArgs []*ConnMockReadParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnMockReadExpectation specifies expectation struct of the Conn.Read
type ConnMockReadExpectation struct {
	mock               *ConnMock
	params             *ConnMockReadParams
	paramPtrs          *ConnMockReadParamPtrs
	expectationOrigins ConnMockReadExpectationOrigins
	results            *ConnMockReadResults
	returnOrigin       string
	Counter            uint64
}

// ConnMockReadParams contains parameters of the Conn.Read
type ConnMockReadParams struct {
	b []byte
}

// ConnMockReadParamPtrs contains pointers to parameters of the Conn.Read
type ConnMockReadParamPtrs struct {
	b *[]byte
}

// ConnMockReadResults contains results of the Conn.Read
type ConnMockReadResults struct {
	n   int
	err error
}

// ConnMockReadOrigins contains origins of expectations of the Conn.Read
type ConnMockReadExpectationOrigins struct {
	origin  string
	originB string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRead *mConnMockRead) Optional() *mConnMockRead {
	mmRead.optional = true
	return mmRead
}

// Expect sets up expected params for Conn.Read
func (mmRead *mConnMockRead) Expect(b []byte) *mConnMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("ConnMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &ConnMockReadExpectation{}
	}

	if mmRead.defaultExpectation.paramPtrs != nil {
		mmRead.mock.t.Fatalf("ConnMock.Read mock is already set by ExpectParams functions")
	}

	mmRead.defaultExpectation.params = &ConnMockReadParams{b}
	mmRead.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// ExpectBParam1 sets up expected param b for Conn.Read
func (mmRead *mConnMockRead) ExpectBParam1(b []byte) *mConnMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("ConnMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &ConnMockReadExpectation{}
	}

	if mmRead.defaultExpectation.params != nil {
		mmRead.mock.t.Fatalf("ConnMock.Read mock is already set by Expect")
	}

	if mmRead.defaultExpectation.paramPtrs == nil {
		mmRead.defaultExpectation.paramPtrs = &ConnMockReadParamPtrs{}
	}
	mmRead.defaultExpectation.paramPtrs.b = &b
	mmRead.defaultExpectation.expectationOrigins.originB = minimock.CallerInfo(1)

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the Conn.Read
func (mmRead *mConnMockRead) Inspect(f func(b []byte)) *mConnMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for ConnMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by Conn.Read
func (mmRead *mConnMockRead) Return(n int, err error) *ConnMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("ConnMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &ConnMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &ConnMockReadResults{n, err}
	mmRead.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRead.mock
}

// Set uses given function f to mock the Conn.Read method
func (mmRead *mConnMockRead) Set(f func(b []byte) (n int, err error)) *ConnMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the Conn.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the Conn.Read method")
	}

	mmRead.mock.funcRead = f
	mmRead.mock.funcReadOrigin = minimock.CallerInfo(1)
	return mmRead.mock
}

// When sets expectation for the Conn.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mConnMockRead) When(b []byte) *ConnMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("ConnMock.Read mock is already set by Set")
	}

	expectation := &ConnMockReadExpectation{
		mock:               mmRead.mock,
		params:             &ConnMockReadParams{b},
		expectationOrigins: ConnMockReadExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up Conn.Read return parameters for the expectation previously defined by the When method
func (e *ConnMockReadExpectation) Then(n int, err error) *ConnMock {
	e.results = &ConnMockReadResults{n, err}
	return e.mock
}

// Times sets number of times Conn.Read should be invoked
func (mmRead *mConnMockRead) Times(n uint64) *mConnMockRead {
	if n == 0 {
		mmRead.mock.t.Fatalf("Times of ConnMock.Read mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRead.expectedInvocations, n)
	mmRead.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRead
}

func (mmRead *mConnMockRead) invocationsDone() bool {
	if len(mmRead.expectations) == 0 && mmRead.defaultExpectation == nil && mmRead.mock.funcRead == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRead.mock.afterReadCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRead.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Read implements mm_net.Conn
func (mmRead *ConnMock) Read(b []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	mmRead.t.Helper()

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(b)
	}

	mm_params := ConnMockReadParams{b}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, &mm_params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		mm_want := mmRead.ReadMock.defaultExpectation.params
		mm_want_ptrs := mmRead.ReadMock.defaultExpectation.paramPtrs

		mm_got := ConnMockReadParams{b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmRead.t.Errorf("ConnMock.Read got unexpected parameter b, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRead.ReadMock.defaultExpectation.expectationOrigins.originB, *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRead.t.Errorf("ConnMock.Read got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRead.ReadMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRead.ReadMock.defaultExpectation.results
		if mm_results == nil {
			mmRead.t.Fatal("No results are set for the ConnMock.Read")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(b)
	}
	mmRead.t.Fatalf("Unexpected call to ConnMock.Read. %v", b)
	return
}

// ReadAfterCounter returns a count of finished ConnMock.Read invocations
func (mmRead *ConnMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of ConnMock.Read invocations
func (mmRead *ConnMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mConnMockRead) Calls() []*ConnMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*ConnMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockReadDone() bool {
	if m.ReadMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReadMock.invocationsDone()
}

// MinimockReadInspect logs each unmet expectation
func (m *ConnMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.Read at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReadCounter := mm_atomic.LoadUint64(&m.afterReadCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && afterReadCounter < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConnMock.Read at\n%s", m.ReadMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConnMock.Read at\n%s with params: %#v", m.ReadMock.defaultExpectation.expectationOrigins.origin, *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && afterReadCounter < 1 {
		m.t.Errorf("Expected call to ConnMock.Read at\n%s", m.funcReadOrigin)
	}

	if !m.ReadMock.invocationsDone() && afterReadCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnMock.Read at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReadMock.expectedInvocations), m.ReadMock.expectedInvocationsOrigin, afterReadCounter)
	}
}

type mConnMockRemoteAddr struct {
	optional           bool
	mock               *ConnMock
	defaultExpectation *ConnMockRemoteAddrExpectation
	expectations       []*ConnMockRemoteAddrExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnMockRemoteAddrExpectation specifies expectation struct of the Conn.RemoteAddr
type ConnMockRemoteAddrExpectation struct {
	mock *ConnMock

	results      *ConnMockRemoteAddrResults
	returnOrigin string
	Counter      uint64
}

// ConnMockRemoteAddrResults contains results of the Conn.RemoteAddr
type ConnMockRemoteAddrResults struct {
	a1 mm_net.Addr
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoteAddr *mConnMockRemoteAddr) Optional() *mConnMockRemoteAddr {
	mmRemoteAddr.optional = true
	return mmRemoteAddr
}

// Expect sets up expected params for Conn.RemoteAddr
func (mmRemoteAddr *mConnMockRemoteAddr) Expect() *mConnMockRemoteAddr {
	if mmRemoteAddr.mock.funcRemoteAddr != nil {
		mmRemoteAddr.mock.t.Fatalf("ConnMock.RemoteAddr mock is already set by Set")
	}

	if mmRemoteAddr.defaultExpectation == nil {
		mmRemoteAddr.defaultExpectation = &ConnMockRemoteAddrExpectation{}
	}

	return mmRemoteAddr
}

// Inspect accepts an inspector function that has same arguments as the Conn.RemoteAddr
func (mmRemoteAddr *mConnMockRemoteAddr) Inspect(f func()) *mConnMockRemoteAddr {
	if mmRemoteAddr.mock.inspectFuncRemoteAddr != nil {
		mmRemoteAddr.mock.t.Fatalf("Inspect function is already set for ConnMock.RemoteAddr")
	}

	mmRemoteAddr.mock.inspectFuncRemoteAddr = f

	return mmRemoteAddr
}

// Return sets up results that will be returned by Conn.RemoteAddr
func (mmRemoteAddr *mConnMockRemoteAddr) Return(a1 mm_net.Addr) *ConnMock {
	if mmRemoteAddr.mock.funcRemoteAddr != nil {
		mmRemoteAddr.mock.t.Fatalf("ConnMock.RemoteAddr mock is already set by Set")
	}

	if mmRemoteAddr.defaultExpectation == nil {
		mmRemoteAddr.defaultExpectation = &ConnMockRemoteAddrExpectation{mock: mmRemoteAddr.mock}
	}
	mmRemoteAddr.defaultExpectation.results = &ConnMockRemoteAddrResults{a1}
	mmRemoteAddr.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoteAddr.mock
}

// Set uses given function f to mock the Conn.RemoteAddr method
func (mmRemoteAddr *mConnMockRemoteAddr) Set(f func() (a1 mm_net.Addr)) *ConnMock {
	if mmRemoteAddr.defaultExpectation != nil {
		mmRemoteAddr.mock.t.Fatalf("Default expectation is already set for the Conn.RemoteAddr method")
	}

	if len(mmRemoteAddr.expectations) > 0 {
		mmRemoteAddr.mock.t.Fatalf("Some expectations are already set for the Conn.RemoteAddr method")
	}

	mmRemoteAddr.mock.funcRemoteAddr = f
	mmRemoteAddr.mock.funcRemoteAddrOrigin = minimock.CallerInfo(1)
	return mmRemoteAddr.mock
}

// Times sets number of times Conn.RemoteAddr should be invoked
func (mmRemoteAddr *mConnMockRemoteAddr) Times(n uint64) *mConnMockRemoteAddr {
	if n == 0 {
		mmRemoteAddr.mock.t.Fatalf("Times of ConnMock.RemoteAddr mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoteAddr.expectedInvocations, n)
	mmRemoteAddr.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoteAddr
}

func (mmRemoteAddr *mConnMockRemoteAddr) invocationsDone() bool {
	if len(mmRemoteAddr.expectations) == 0 && mmRemoteAddr.defaultExpectation == nil && mmRemoteAddr.mock.funcRemoteAddr == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoteAddr.mock.afterRemoteAddrCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoteAddr.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoteAddr implements mm_net.Conn
func (mmRemoteAddr *ConnMock) RemoteAddr() (a1 mm_net.Addr) {
	mm_atomic.AddUint64(&mmRemoteAddr.beforeRemoteAddrCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoteAddr.afterRemoteAddrCounter, 1)

	mmRemoteAddr.t.Helper()

	if mmRemoteAddr.inspectFuncRemoteAddr != nil {
		mmRemoteAddr.inspectFuncRemoteAddr()
	}

	if mmRemoteAddr.RemoteAddrMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoteAddr.RemoteAddrMock.defaultExpectation.Counter, 1)

		mm_results := mmRemoteAddr.RemoteAddrMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoteAddr.t.Fatal("No results are set for the ConnMock.RemoteAddr")
		}
		return (*mm_results).a1
	}
	if mmRemoteAddr.funcRemoteAddr != nil {
		return mmRemoteAddr.funcRemoteAddr()
	}
	mmRemoteAddr.t.Fatalf("Unexpected call to ConnMock.RemoteAddr.")
	return
}

// RemoteAddrAfterCounter returns a count of finished ConnMock.RemoteAddr invocations
func (mmRemoteAddr *ConnMock) RemoteAddrAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteAddr.afterRemoteAddrCounter)
}

// RemoteAddrBeforeCounter returns a count of ConnMock.RemoteAddr invocations
func (mmRemoteAddr *ConnMock) RemoteAddrBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoteAddr.beforeRemoteAddrCounter)
}

// MinimockRemoteAddrDone returns true if the count of the RemoteAddr invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockRemoteAddrDone() bool {
	if m.RemoteAddrMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoteAddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoteAddrMock.invocationsDone()
}

// MinimockRemoteAddrInspect logs each unmet expectation
func (m *ConnMock) MinimockRemoteAddrInspect() {
	for _, e := range m.RemoteAddrMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConnMock.RemoteAddr")
		}
	}

	afterRemoteAddrCounter := mm_atomic.LoadUint64(&m.afterRemoteAddrCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoteAddrMock.defaultExpectation != nil && afterRemoteAddrCounter < 1 {
		m.t.Errorf("Expected call to ConnMock.RemoteAddr at\n%s", m.RemoteAddrMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoteAddr != nil && afterRemoteAddrCounter < 1 {
		m.t.Errorf("Expected call to ConnMock.RemoteAddr at\n%s", m.funcRemoteAddrOrigin)
	}

	if !m.RemoteAddrMock.invocationsDone() && afterRemoteAddrCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnMock.RemoteAddr at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoteAddrMock.expectedInvocations), m.RemoteAddrMock.expectedInvocationsOrigin, afterRemoteAddrCounter)
	}
}

type mConnMockSetDeadline struct {
	optional           bool
	mock               *ConnMock
	defaultExpectation *ConnMockSetDeadlineExpectation
	expectations       []*ConnMockSetDeadlineExpectation

	callArgs []*ConnMockSetDeadlineParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnMockSetDeadlineExpectation specifies expectation struct of the Conn.SetDeadline
type ConnMockSetDeadlineExpectation struct {
	mock               *ConnMock
	params             *ConnMockSetDeadlineParams
	paramPtrs          *ConnMockSetDeadlineParamPtrs
	expectationOrigins ConnMockSetDeadlineExpectationOrigins
	results            *ConnMockSetDeadlineResults
	returnOrigin       string
	Counter            uint64
}

// ConnMockSetDeadlineParams contains parameters of the Conn.SetDeadline
type ConnMockSetDeadlineParams struct {
	t time.Time
}

// ConnMockSetDeadlineParamPtrs contains pointers to parameters of the Conn.SetDeadline
type ConnMockSetDeadlineParamPtrs struct {
	t *time.Time
}

// ConnMockSetDeadlineResults contains results of the Conn.SetDeadline
type ConnMockSetDeadlineResults struct {
	err error
}

// ConnMockSetDeadlineOrigins contains origins of expectations of the Conn.SetDeadline
type ConnMockSetDeadlineExpectationOrigins struct {
	origin  string
	originT string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetDeadline *mConnMockSetDeadline) Optional() *mConnMockSetDeadline {
	mmSetDeadline.optional = true
	return mmSetDeadline
}

// Expect sets up expected params for Conn.SetDeadline
func (mmSetDeadline *mConnMockSetDeadline) Expect(t time.Time) *mConnMockSetDeadline {
	if mmSetDeadline.mock.funcSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("ConnMock.SetDeadline mock is already set by Set")
	}

	if mmSetDeadline.defaultExpectation == nil {
		mmSetDeadline.defaultExpectation = &ConnMockSetDeadlineExpectation{}
	}

	if mmSetDeadline.defaultExpectation.paramPtrs != nil {
		mmSetDeadline.mock.t.Fatalf("ConnMock.SetDeadline mock is already set by ExpectParams functions")
	}

	mmSetDeadline.defaultExpectation.params = &ConnMockSetDeadlineParams{t}
	mmSetDeadline.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetDeadline.expectations {
		if minimock.Equal(e.params, mmSetDeadline.defaultExpectation.params) {
			mmSetDeadline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDeadline.defaultExpectation.params)
		}
	}

	return mmSetDeadline
}

// ExpectTParam1 sets up expected param t for Conn.SetDeadline
func (mmSetDeadline *mConnMockSetDeadline) ExpectTParam1(t time.Time) *mConnMockSetDeadline {
	if mmSetDeadline.mock.funcSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("ConnMock.SetDeadline mock is already set by Set")
	}

	if mmSetDeadline.defaultExpectation == nil {
		mmSetDeadline.defaultExpectation = &ConnMockSetDeadlineExpectation{}
	}

	if mmSetDeadline.defaultExpectation.params != nil {
		mmSetDeadline.mock.t.Fatalf("ConnMock.SetDeadline mock is already set by Expect")
	}

	if mmSetDeadline.defaultExpectation.paramPtrs == nil {
		mmSetDeadline.defaultExpectation.paramPtrs = &ConnMockSetDeadlineParamPtrs{}
	}
	mmSetDeadline.defaultExpectation.paramPtrs.t = &t
	mmSetDeadline.defaultExpectation.expectationOrigins.originT = minimock.CallerInfo(1)

	return mmSetDeadline
}

// Inspect accepts an inspector function that has same arguments as the Conn.SetDeadline
func (mmSetDeadline *mConnMockSetDeadline) Inspect(f func(t time.Time)) *mConnMockSetDeadline {
	if mmSetDeadline.mock.inspectFuncSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("Inspect function is already set for ConnMock.SetDeadline")
	}

	mmSetDeadline.mock.inspectFuncSetDeadline = f

	return mmSetDeadline
}

// Return sets up results that will be returned by Conn.SetDeadline
func (mmSetDeadline *mConnMockSetDeadline) Return(err error) *ConnMock {
	if mmSetDeadline.mock.funcSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("ConnMock.SetDeadline mock is already set by Set")
	}

	if mmSetDeadline.defaultExpectation == nil {
		mmSetDeadline.defaultExpectation = &ConnMockSetDeadlineExpectation{mock: mmSetDeadline.mock}
	}
	mmSetDeadline.defaultExpectation.results = &ConnMockSetDeadlineResults{err}
	mmSetDeadline.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetDeadline.mock
}

// Set uses given function f to mock the Conn.SetDeadline method
func (mmSetDeadline *mConnMockSetDeadline) Set(f func(t time.Time) (err error)) *ConnMock {
	if mmSetDeadline.defaultExpectation != nil {
		mmSetDeadline.mock.t.Fatalf("Default expectation is already set for the Conn.SetDeadline method")
	}

	if len(mmSetDeadline.expectations) > 0 {
		mmSetDeadline.mock.t.Fatalf("Some expectations are already set for the Conn.SetDeadline method")
	}

	mmSetDeadline.mock.funcSetDeadline = f
	mmSetDeadline.mock.funcSetDeadlineOrigin = minimock.CallerInfo(1)
	return mmSetDeadline.mock
}

// When sets expectation for the Conn.SetDeadline which will trigger the result defined by the following
// Then helper
func (mmSetDeadline *mConnMockSetDeadline) When(t time.Time) *ConnMockSetDeadlineExpectation {
	if mmSetDeadline.mock.funcSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("ConnMock.SetDeadline mock is already set by Set")
	}

	expectation := &ConnMockSetDeadlineExpectation{
		mock:               mmSetDeadline.mock,
		params:             &ConnMockSetDeadlineParams{t},
		expectationOrigins: ConnMockSetDeadlineExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetDeadline.expectations = append(mmSetDeadline.expectations, expectation)
	return expectation
}

// Then sets up Conn.SetDeadline return parameters for the expectation previously defined by the When method
func (e *ConnMockSetDeadlineExpectation) Then(err error) *ConnMock {
	e.results = &ConnMockSetDeadlineResults{err}
	return e.mock
}

// Times sets number of times Conn.SetDeadline should be invoked
func (mmSetDeadline *mConnMockSetDeadline) Times(n uint64) *mConnMockSetDeadline {
	if n == 0 {
		mmSetDeadline.mock.t.Fatalf("Times of ConnMock.SetDeadline mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetDeadline.expectedInvocations, n)
	mmSetDeadline.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetDeadline
}

func (mmSetDeadline *mConnMockSetDeadline) invocationsDone() bool {
	if len(mmSetDeadline.expectations) == 0 && mmSetDeadline.defaultExpectation == nil && mmSetDeadline.mock.funcSetDeadline == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetDeadline.mock.afterSetDeadlineCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetDeadline.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetDeadline implements mm_net.Conn
func (mmSetDeadline *ConnMock) SetDeadline(t time.Time) (err error) {
	mm_atomic.AddUint64(&mmSetDeadline.beforeSetDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDeadline.afterSetDeadlineCounter, 1)

	mmSetDeadline.t.Helper()

	if mmSetDeadline.inspectFuncSetDeadline != nil {
		mmSetDeadline.inspectFuncSetDeadline(t)
	}

	mm_params := ConnMockSetDeadlineParams{t}

	// Record call args
	mmSetDeadline.SetDeadlineMock.mutex.Lock()
	mmSetDeadline.SetDeadlineMock.callArgs = append(mmSetDeadline.SetDeadlineMock.callArgs, &mm_params)
	mmSetDeadline.SetDeadlineMock.mutex.Unlock()

	for _, e := range mmSetDeadline.SetDeadlineMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetDeadline.SetDeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDeadline.SetDeadlineMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDeadline.SetDeadlineMock.defaultExpectation.params
		mm_want_ptrs := mmSetDeadline.SetDeadlineMock.defaultExpectation.paramPtrs

		mm_got := ConnMockSetDeadlineParams{t}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.t != nil && !minimock.Equal(*mm_want_ptrs.t, mm_got.t) {
				mmSetDeadline.t.Errorf("ConnMock.SetDeadline got unexpected parameter t, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetDeadline.SetDeadlineMock.defaultExpectation.expectationOrigins.originT, *mm_want_ptrs.t, mm_got.t, minimock.Diff(*mm_want_ptrs.t, mm_got.t))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDeadline.t.Errorf("ConnMock.SetDeadline got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetDeadline.SetDeadlineMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetDeadline.SetDeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmSetDeadline.t.Fatal("No results are set for the ConnMock.SetDeadline")
		}
		return (*mm_results).err
	}
	if mmSetDeadline.funcSetDeadline != nil {
		return mmSetDeadline.funcSetDeadline(t)
	}
	mmSetDeadline.t.Fatalf("Unexpected call to ConnMock.SetDeadline. %v", t)
	return
}

// SetDeadlineAfterCounter returns a count of finished ConnMock.SetDeadline invocations
func (mmSetDeadline *ConnMock) SetDeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDeadline.afterSetDeadlineCounter)
}

// SetDeadlineBeforeCounter returns a count of ConnMock.SetDeadline invocations
func (mmSetDeadline *ConnMock) SetDeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDeadline.beforeSetDeadlineCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.SetDeadline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDeadline *mConnMockSetDeadline) Calls() []*ConnMockSetDeadlineParams {
	mmSetDeadline.mutex.RLock()

	argCopy := make([]*ConnMockSetDeadlineParams, len(mmSetDeadline.callArgs))
	copy(argCopy, mmSetDeadline.callArgs)

	mmSetDeadline.mutex.RUnlock()

	return argCopy
}

// MinimockSetDeadlineDone returns true if the count of the SetDeadline invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockSetDeadlineDone() bool {
	if m.SetDeadlineMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetDeadlineMock.invocationsDone()
}

// MinimockSetDeadlineInspect logs each unmet expectation
func (m *ConnMock) MinimockSetDeadlineInspect() {
	for _, e := range m.SetDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.SetDeadline at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetDeadlineCounter := mm_atomic.LoadUint64(&m.afterSetDeadlineCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetDeadlineMock.defaultExpectation != nil && afterSetDeadlineCounter < 1 {
		if m.SetDeadlineMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConnMock.SetDeadline at\n%s", m.SetDeadlineMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConnMock.SetDeadline at\n%s with params: %#v", m.SetDeadlineMock.defaultExpectation.expectationOrigins.origin, *m.SetDeadlineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDeadline != nil && afterSetDeadlineCounter < 1 {
		m.t.Errorf("Expected call to ConnMock.SetDeadline at\n%s", m.funcSetDeadlineOrigin)
	}

	if !m.SetDeadlineMock.invocationsDone() && afterSetDeadlineCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnMock.SetDeadline at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetDeadlineMock.expectedInvocations), m.SetDeadlineMock.expectedInvocationsOrigin, afterSetDeadlineCounter)
	}
}

type mConnMockSetReadDeadline struct {
	optional           bool
	mock               *ConnMock
	defaultExpectation *ConnMockSetReadDeadlineExpectation
	expectations       []*ConnMockSetReadDeadlineExpectation

	callArgs []*ConnMockSetReadDeadlineParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnMockSetReadDeadlineExpectation specifies expectation struct of the Conn.SetReadDeadline
type ConnMockSetReadDeadlineExpectation struct {
	mock               *ConnMock
	params             *ConnMockSetReadDeadlineParams
	paramPtrs          *ConnMockSetReadDeadlineParamPtrs
	expectationOrigins ConnMockSetReadDeadlineExpectationOrigins
	results            *ConnMockSetReadDeadlineResults
	returnOrigin       string
	Counter            uint64
}

// ConnMockSetReadDeadlineParams contains parameters of the Conn.SetReadDeadline
type ConnMockSetReadDeadlineParams struct {
	t time.Time
}

// ConnMockSetReadDeadlineParamPtrs contains pointers to parameters of the Conn.SetReadDeadline
type ConnMockSetReadDeadlineParamPtrs struct {
	t *time.Time
}

// ConnMockSetReadDeadlineResults contains results of the Conn.SetReadDeadline
type ConnMockSetReadDeadlineResults struct {
	err error
}

// ConnMockSetReadDeadlineOrigins contains origins of expectations of the Conn.SetReadDeadline
type ConnMockSetReadDeadlineExpectationOrigins struct {
	origin  string
	originT string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetReadDeadline *mConnMockSetReadDeadline) Optional() *mConnMockSetReadDeadline {
	mmSetReadDeadline.optional = true
	return mmSetReadDeadline
}

// Expect sets up expected params for Conn.SetReadDeadline
func (mmSetReadDeadline *mConnMockSetReadDeadline) Expect(t time.Time) *mConnMockSetReadDeadline {
	if mmSetReadDeadline.mock.funcSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("ConnMock.SetReadDeadline mock is already set by Set")
	}

	if mmSetReadDeadline.defaultExpectation == nil {
		mmSetReadDeadline.defaultExpectation = &ConnMockSetReadDeadlineExpectation{}
	}

	if mmSetReadDeadline.defaultExpectation.paramPtrs != nil {
		mmSetReadDeadline.mock.t.Fatalf("ConnMock.SetReadDeadline mock is already set by ExpectParams functions")
	}

	mmSetReadDeadline.defaultExpectation.params = &ConnMockSetReadDeadlineParams{t}
	mmSetReadDeadline.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetReadDeadline.expectations {
		if minimock.Equal(e.params, mmSetReadDeadline.defaultExpectation.params) {
			mmSetReadDeadline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetReadDeadline.defaultExpectation.params)
		}
	}

	return mmSetReadDeadline
}

// ExpectTParam1 sets up expected param t for Conn.SetReadDeadline
func (mmSetReadDeadline *mConnMockSetReadDeadline) ExpectTParam1(t time.Time) *mConnMockSetReadDeadline {
	if mmSetReadDeadline.mock.funcSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("ConnMock.SetReadDeadline mock is already set by Set")
	}

	if mmSetReadDeadline.defaultExpectation == nil {
		mmSetReadDeadline.defaultExpectation = &ConnMockSetReadDeadlineExpectation{}
	}

	if mmSetReadDeadline.defaultExpectation.params != nil {
		mmSetReadDeadline.mock.t.Fatalf("ConnMock.SetReadDeadline mock is already set by Expect")
	}

	if mmSetReadDeadline.defaultExpectation.paramPtrs == nil {
		mmSetReadDeadline.defaultExpectation.paramPtrs = &ConnMockSetReadDeadlineParamPtrs{}
	}
	mmSetReadDeadline.defaultExpectation.paramPtrs.t = &t
	mmSetReadDeadline.defaultExpectation.expectationOrigins.originT = minimock.CallerInfo(1)

	return mmSetReadDeadline
}

// Inspect accepts an inspector function that has same arguments as the Conn.SetReadDeadline
func (mmSetReadDeadline *mConnMockSetReadDeadline) Inspect(f func(t time.Time)) *mConnMockSetReadDeadline {
	if mmSetReadDeadline.mock.inspectFuncSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("Inspect function is already set for ConnMock.SetReadDeadline")
	}

	mmSetReadDeadline.mock.inspectFuncSetReadDeadline = f

	return mmSetReadDeadline
}

// Return sets up results that will be returned by Conn.SetReadDeadline
func (mmSetReadDeadline *mConnMockSetReadDeadline) Return(err error) *ConnMock {
	if mmSetReadDeadline.mock.funcSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("ConnMock.SetReadDeadline mock is already set by Set")
	}

	if mmSetReadDeadline.defaultExpectation == nil {
		mmSetReadDeadline.defaultExpectation = &ConnMockSetReadDeadlineExpectation{mock: mmSetReadDeadline.mock}
	}
	mmSetReadDeadline.defaultExpectation.results = &ConnMockSetReadDeadlineResults{err}
	mmSetReadDeadline.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetReadDeadline.mock
}

// Set uses given function f to mock the Conn.SetReadDeadline method
func (mmSetReadDeadline *mConnMockSetReadDeadline) Set(f func(t time.Time) (err error)) *ConnMock {
	if mmSetReadDeadline.defaultExpectation != nil {
		mmSetReadDeadline.mock.t.Fatalf("Default expectation is already set for the Conn.SetReadDeadline method")
	}

	if len(mmSetReadDeadline.expectations) > 0 {
		mmSetReadDeadline.mock.t.Fatalf("Some expectations are already set for the Conn.SetReadDeadline method")
	}

	mmSetReadDeadline.mock.funcSetReadDeadline = f
	mmSetReadDeadline.mock.funcSetReadDeadlineOrigin = minimock.CallerInfo(1)
	return mmSetReadDeadline.mock
}

// When sets expectation for the Conn.SetReadDeadline which will trigger the result defined by the following
// Then helper
func (mmSetReadDeadline *mConnMockSetReadDeadline) When(t time.Time) *ConnMockSetReadDeadlineExpectation {
	if mmSetReadDeadline.mock.funcSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("ConnMock.SetReadDeadline mock is already set by Set")
	}

	expectation := &ConnMockSetReadDeadlineExpectation{
		mock:               mmSetReadDeadline.mock,
		params:             &ConnMockSetReadDeadlineParams{t},
		expectationOrigins: ConnMockSetReadDeadlineExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetReadDeadline.expectations = append(mmSetReadDeadline.expectations, expectation)
	return expectation
}

// Then sets up Conn.SetReadDeadline return parameters for the expectation previously defined by the When method
func (e *ConnMockSetReadDeadlineExpectation) Then(err error) *ConnMock {
	e.results = &ConnMockSetReadDeadlineResults{err}
	return e.mock
}

// Times sets number of times Conn.SetReadDeadline should be invoked
func (mmSetReadDeadline *mConnMockSetReadDeadline) Times(n uint64) *mConnMockSetReadDeadline {
	if n == 0 {
		mmSetReadDeadline.mock.t.Fatalf("Times of ConnMock.SetReadDeadline mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetReadDeadline.expectedInvocations, n)
	mmSetReadDeadline.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetReadDeadline
}

func (mmSetReadDeadline *mConnMockSetReadDeadline) invocationsDone() bool {
	if len(mmSetReadDeadline.expectations) == 0 && mmSetReadDeadline.defaultExpectation == nil && mmSetReadDeadline.mock.funcSetReadDeadline == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetReadDeadline.mock.afterSetReadDeadlineCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetReadDeadline.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetReadDeadline implements mm_net.Conn
func (mmSetReadDeadline *ConnMock) SetReadDeadline(t time.Time) (err error) {
	mm_atomic.AddUint64(&mmSetReadDeadline.beforeSetReadDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmSetReadDeadline.afterSetReadDeadlineCounter, 1)

	mmSetReadDeadline.t.Helper()

	if mmSetReadDeadline.inspectFuncSetReadDeadline != nil {
		mmSetReadDeadline.inspectFuncSetReadDeadline(t)
	}

	mm_params := ConnMockSetReadDeadlineParams{t}

	// Record call args
	mmSetReadDeadline.SetReadDeadlineMock.mutex.Lock()
	mmSetReadDeadline.SetReadDeadlineMock.callArgs = append(mmSetReadDeadline.SetReadDeadlineMock.callArgs, &mm_params)
	mmSetReadDeadline.SetReadDeadlineMock.mutex.Unlock()

	for _, e := range mmSetReadDeadline.SetReadDeadlineMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.Counter, 1)
		mm_want := mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.params
		mm_want_ptrs := mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.paramPtrs

		mm_got := ConnMockSetReadDeadlineParams{t}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.t != nil && !minimock.Equal(*mm_want_ptrs.t, mm_got.t) {
				mmSetReadDeadline.t.Errorf("ConnMock.SetReadDeadline got unexpected parameter t, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.expectationOrigins.originT, *mm_want_ptrs.t, mm_got.t, minimock.Diff(*mm_want_ptrs.t, mm_got.t))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetReadDeadline.t.Errorf("ConnMock.SetReadDeadline got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmSetReadDeadline.t.Fatal("No results are set for the ConnMock.SetReadDeadline")
		}
		return (*mm_results).err
	}
	if mmSetReadDeadline.funcSetReadDeadline != nil {
		return mmSetReadDeadline.funcSetReadDeadline(t)
	}
	mmSetReadDeadline.t.Fatalf("Unexpected call to ConnMock.SetReadDeadline. %v", t)
	return
}

// SetReadDeadlineAfterCounter returns a count of finished ConnMock.SetReadDeadline invocations
func (mmSetReadDeadline *ConnMock) SetReadDeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetReadDeadline.afterSetReadDeadlineCounter)
}

// SetReadDeadlineBeforeCounter returns a count of ConnMock.SetReadDeadline invocations
func (mmSetReadDeadline *ConnMock) SetReadDeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetReadDeadline.beforeSetReadDeadlineCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.SetReadDeadline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetReadDeadline *mConnMockSetReadDeadline) Calls() []*ConnMockSetReadDeadlineParams {
	mmSetReadDeadline.mutex.RLock()

	argCopy := make([]*ConnMockSetReadDeadlineParams, len(mmSetReadDeadline.callArgs))
	copy(argCopy, mmSetReadDeadline.callArgs)

	mmSetReadDeadline.mutex.RUnlock()

	return argCopy
}

// MinimockSetReadDeadlineDone returns true if the count of the SetReadDeadline invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockSetReadDeadlineDone() bool {
	if m.SetReadDeadlineMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetReadDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetReadDeadlineMock.invocationsDone()
}

// MinimockSetReadDeadlineInspect logs each unmet expectation
func (m *ConnMock) MinimockSetReadDeadlineInspect() {
	for _, e := range m.SetReadDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.SetReadDeadline at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetReadDeadlineCounter := mm_atomic.LoadUint64(&m.afterSetReadDeadlineCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetReadDeadlineMock.defaultExpectation != nil && afterSetReadDeadlineCounter < 1 {
		if m.SetReadDeadlineMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConnMock.SetReadDeadline at\n%s", m.SetReadDeadlineMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConnMock.SetReadDeadline at\n%s with params: %#v", m.SetReadDeadlineMock.defaultExpectation.expectationOrigins.origin, *m.SetReadDeadlineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetReadDeadline != nil && afterSetReadDeadlineCounter < 1 {
		m.t.Errorf("Expected call to ConnMock.SetReadDeadline at\n%s", m.funcSetReadDeadlineOrigin)
	}

	if !m.SetReadDeadlineMock.invocationsDone() && afterSetReadDeadlineCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnMock.SetReadDeadline at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetReadDeadlineMock.expectedInvocations), m.SetReadDeadlineMock.expectedInvocationsOrigin, afterSetReadDeadlineCounter)
	}
}

type mConnMockSetWriteDeadline struct {
	optional           bool
	mock               *ConnMock
	defaultExpectation *ConnMockSetWriteDeadlineExpectation
	expectations       []*ConnMockSetWriteDeadlineExpectation

	callArgs []*ConnMockSetWriteDeadlineParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnMockSetWriteDeadlineExpectation specifies expectation struct of the Conn.SetWriteDeadline
type ConnMockSetWriteDeadlineExpectation struct {
	mock               *ConnMock
	params             *ConnMockSetWriteDeadlineParams
	paramPtrs          *ConnMockSetWriteDeadlineParamPtrs
	expectationOrigins ConnMockSetWriteDeadlineExpectationOrigins
	results            *ConnMockSetWriteDeadlineResults
	returnOrigin       string
	Counter            uint64
}

// ConnMockSetWriteDeadlineParams contains parameters of the Conn.SetWriteDeadline
type ConnMockSetWriteDeadlineParams struct {
	t time.Time
}

// ConnMockSetWriteDeadlineParamPtrs contains pointers to parameters of the Conn.SetWriteDeadline
type ConnMockSetWriteDeadlineParamPtrs struct {
	t *time.Time
}

// ConnMockSetWriteDeadlineResults contains results of the Conn.SetWriteDeadline
type ConnMockSetWriteDeadlineResults struct {
	err error
}

// ConnMockSetWriteDeadlineOrigins contains origins of expectations of the Conn.SetWriteDeadline
type ConnMockSetWriteDeadlineExpectationOrigins struct {
	origin  string
	originT string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Optional() *mConnMockSetWriteDeadline {
	mmSetWriteDeadline.optional = true
	return mmSetWriteDeadline
}

// Expect sets up expected params for Conn.SetWriteDeadline
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Expect(t time.Time) *mConnMockSetWriteDeadline {
	if mmSetWriteDeadline.mock.funcSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("ConnMock.SetWriteDeadline mock is already set by Set")
	}

	if mmSetWriteDeadline.defaultExpectation == nil {
		mmSetWriteDeadline.defaultExpectation = &ConnMockSetWriteDeadlineExpectation{}
	}

	if mmSetWriteDeadline.defaultExpectation.paramPtrs != nil {
		mmSetWriteDeadline.mock.t.Fatalf("ConnMock.SetWriteDeadline mock is already set by ExpectParams functions")
	}

	mmSetWriteDeadline.defaultExpectation.params = &ConnMockSetWriteDeadlineParams{t}
	mmSetWriteDeadline.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetWriteDeadline.expectations {
		if minimock.Equal(e.params, mmSetWriteDeadline.defaultExpectation.params) {
			mmSetWriteDeadline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetWriteDeadline.defaultExpectation.params)
		}
	}

	return mmSetWriteDeadline
}

// ExpectTParam1 sets up expected param t for Conn.SetWriteDeadline
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) ExpectTParam1(t time.Time) *mConnMockSetWriteDeadline {
	if mmSetWriteDeadline.mock.funcSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("ConnMock.SetWriteDeadline mock is already set by Set")
	}

	if mmSetWriteDeadline.defaultExpectation == nil {
		mmSetWriteDeadline.defaultExpectation = &ConnMockSetWriteDeadlineExpectation{}
	}

	if mmSetWriteDeadline.defaultExpectation.params != nil {
		mmSetWriteDeadline.mock.t.Fatalf("ConnMock.SetWriteDeadline mock is already set by Expect")
	}

	if mmSetWriteDeadline.defaultExpectation.paramPtrs == nil {
		mmSetWriteDeadline.defaultExpectation.paramPtrs = &ConnMockSetWriteDeadlineParamPtrs{}
	}
	mmSetWriteDeadline.defaultExpectation.paramPtrs.t = &t
	mmSetWriteDeadline.defaultExpectation.expectationOrigins.originT = minimock.CallerInfo(1)

	return mmSetWriteDeadline
}

// Inspect accepts an inspector function that has same arguments as the Conn.SetWriteDeadline
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Inspect(f func(t time.Time)) *mConnMockSetWriteDeadline {
	if mmSetWriteDeadline.mock.inspectFuncSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("Inspect function is already set for ConnMock.SetWriteDeadline")
	}

	mmSetWriteDeadline.mock.inspectFuncSetWriteDeadline = f

	return mmSetWriteDeadline
}

// Return sets up results that will be returned by Conn.SetWriteDeadline
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Return(err error) *ConnMock {
	if mmSetWriteDeadline.mock.funcSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("ConnMock.SetWriteDeadline mock is already set by Set")
	}

	if mmSetWriteDeadline.defaultExpectation == nil {
		mmSetWriteDeadline.defaultExpectation = &ConnMockSetWriteDeadlineExpectation{mock: mmSetWriteDeadline.mock}
	}
	mmSetWriteDeadline.defaultExpectation.results = &ConnMockSetWriteDeadlineResults{err}
	mmSetWriteDeadline.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetWriteDeadline.mock
}

// Set uses given function f to mock the Conn.SetWriteDeadline method
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Set(f func(t time.Time) (err error)) *ConnMock {
	if mmSetWriteDeadline.defaultExpectation != nil {
		mmSetWriteDeadline.mock.t.Fatalf("Default expectation is already set for the Conn.SetWriteDeadline method")
	}

	if len(mmSetWriteDeadline.expectations) > 0 {
		mmSetWriteDeadline.mock.t.Fatalf("Some expectations are already set for the Conn.SetWriteDeadline method")
	}

	mmSetWriteDeadline.mock.funcSetWriteDeadline = f
	mmSetWriteDeadline.mock.funcSetWriteDeadlineOrigin = minimock.CallerInfo(1)
	return mmSetWriteDeadline.mock
}

// When sets expectation for the Conn.SetWriteDeadline which will trigger the result defined by the following
// Then helper
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) When(t time.Time) *ConnMockSetWriteDeadlineExpectation {
	if mmSetWriteDeadline.mock.funcSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("ConnMock.SetWriteDeadline mock is already set by Set")
	}

	expectation := &ConnMockSetWriteDeadlineExpectation{
		mock:               mmSetWriteDeadline.mock,
		params:             &ConnMockSetWriteDeadlineParams{t},
		expectationOrigins: ConnMockSetWriteDeadlineExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetWriteDeadline.expectations = append(mmSetWriteDeadline.expectations, expectation)
	return expectation
}

// Then sets up Conn.SetWriteDeadline return parameters for the expectation previously defined by the When method
func (e *ConnMockSetWriteDeadlineExpectation) Then(err error) *ConnMock {
	e.results = &ConnMockSetWriteDeadlineResults{err}
	return e.mock
}

// Times sets number of times Conn.SetWriteDeadline should be invoked
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Times(n uint64) *mConnMockSetWriteDeadline {
	if n == 0 {
		mmSetWriteDeadline.mock.t.Fatalf("Times of ConnMock.SetWriteDeadline mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetWriteDeadline.expectedInvocations, n)
	mmSetWriteDeadline.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetWriteDeadline
}

func (mmSetWriteDeadline *mConnMockSetWriteDeadline) invocationsDone() bool {
	if len(mmSetWriteDeadline.expectations) == 0 && mmSetWriteDeadline.defaultExpectation == nil && mmSetWriteDeadline.mock.funcSetWriteDeadline == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetWriteDeadline.mock.afterSetWriteDeadlineCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetWriteDeadline.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetWriteDeadline implements mm_net.Conn
func (mmSetWriteDeadline *ConnMock) SetWriteDeadline(t time.Time) (err error) {
	mm_atomic.AddUint64(&mmSetWriteDeadline.beforeSetWriteDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmSetWriteDeadline.afterSetWriteDeadlineCounter, 1)

	mmSetWriteDeadline.t.Helper()

	if mmSetWriteDeadline.inspectFuncSetWriteDeadline != nil {
		mmSetWriteDeadline.inspectFuncSetWriteDeadline(t)
	}

	mm_params := ConnMockSetWriteDeadlineParams{t}

	// Record call args
	mmSetWriteDeadline.SetWriteDeadlineMock.mutex.Lock()
	mmSetWriteDeadline.SetWriteDeadlineMock.callArgs = append(mmSetWriteDeadline.SetWriteDeadlineMock.callArgs, &mm_params)
	mmSetWriteDeadline.SetWriteDeadlineMock.mutex.Unlock()

	for _, e := range mmSetWriteDeadline.SetWriteDeadlineMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.Counter, 1)
		mm_want := mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.params
		mm_want_ptrs := mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.paramPtrs

		mm_got := ConnMockSetWriteDeadlineParams{t}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.t != nil && !minimock.Equal(*mm_want_ptrs.t, mm_got.t) {
				mmSetWriteDeadline.t.Errorf("ConnMock.SetWriteDeadline got unexpected parameter t, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.expectationOrigins.originT, *mm_want_ptrs.t, mm_got.t, minimock.Diff(*mm_want_ptrs.t, mm_got.t))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetWriteDeadline.t.Errorf("ConnMock.SetWriteDeadline got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmSetWriteDeadline.t.Fatal("No results are set for the ConnMock.SetWriteDeadline")
		}
		return (*mm_results).err
	}
	if mmSetWriteDeadline.funcSetWriteDeadline != nil {
		return mmSetWriteDeadline.funcSetWriteDeadline(t)
	}
	mmSetWriteDeadline.t.Fatalf("Unexpected call to ConnMock.SetWriteDeadline. %v", t)
	return
}

// SetWriteDeadlineAfterCounter returns a count of finished ConnMock.SetWriteDeadline invocations
func (mmSetWriteDeadline *ConnMock) SetWriteDeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetWriteDeadline.afterSetWriteDeadlineCounter)
}

// SetWriteDeadlineBeforeCounter returns a count of ConnMock.SetWriteDeadline invocations
func (mmSetWriteDeadline *ConnMock) SetWriteDeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetWriteDeadline.beforeSetWriteDeadlineCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.SetWriteDeadline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetWriteDeadline *mConnMockSetWriteDeadline) Calls() []*ConnMockSetWriteDeadlineParams {
	mmSetWriteDeadline.mutex.RLock()

	argCopy := make([]*ConnMockSetWriteDeadlineParams, len(mmSetWriteDeadline.callArgs))
	copy(argCopy, mmSetWriteDeadline.callArgs)

	mmSetWriteDeadline.mutex.RUnlock()

	return argCopy
}

// MinimockSetWriteDeadlineDone returns true if the count of the SetWriteDeadline invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockSetWriteDeadlineDone() bool {
	if m.SetWriteDeadlineMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetWriteDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetWriteDeadlineMock.invocationsDone()
}

// MinimockSetWriteDeadlineInspect logs each unmet expectation
func (m *ConnMock) MinimockSetWriteDeadlineInspect() {
	for _, e := range m.SetWriteDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.SetWriteDeadline at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetWriteDeadlineCounter := mm_atomic.LoadUint64(&m.afterSetWriteDeadlineCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetWriteDeadlineMock.defaultExpectation != nil && afterSetWriteDeadlineCounter < 1 {
		if m.SetWriteDeadlineMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConnMock.SetWriteDeadline at\n%s", m.SetWriteDeadlineMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConnMock.SetWriteDeadline at\n%s with params: %#v", m.SetWriteDeadlineMock.defaultExpectation.expectationOrigins.origin, *m.SetWriteDeadlineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetWriteDeadline != nil && afterSetWriteDeadlineCounter < 1 {
		m.t.Errorf("Expected call to ConnMock.SetWriteDeadline at\n%s", m.funcSetWriteDeadlineOrigin)
	}

	if !m.SetWriteDeadlineMock.invocationsDone() && afterSetWriteDeadlineCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnMock.SetWriteDeadline at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetWriteDeadlineMock.expectedInvocations), m.SetWriteDeadlineMock.expectedInvocationsOrigin, afterSetWriteDeadlineCounter)
	}
}

type mConnMockWrite struct {
	optional           bool
	mock               *ConnMock
	defaultExpectation *ConnMockWriteExpectation
	expectations       []*ConnMockWriteExpectation

	callArgs []*ConnMockWriteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ConnMockWriteExpectation specifies expectation struct of the Conn.Write
type ConnMockWriteExpectation struct {
	mock               *ConnMock
	params             *ConnMockWriteParams
	paramPtrs          *ConnMockWriteParamPtrs
	expectationOrigins ConnMockWriteExpectationOrigins
	results            *ConnMockWriteResults
	returnOrigin       string
	Counter            uint64
}

// ConnMockWriteParams contains parameters of the Conn.Write
type ConnMockWriteParams struct {
	b []byte
}

// ConnMockWriteParamPtrs contains pointers to parameters of the Conn.Write
type ConnMockWriteParamPtrs struct {
	b *[]byte
}

// ConnMockWriteResults contains results of the Conn.Write
type ConnMockWriteResults struct {
	n   int
	err error
}

// ConnMockWriteOrigins contains origins of expectations of the Conn.Write
type ConnMockWriteExpectationOrigins struct {
	origin  string
	originB string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmWrite *mConnMockWrite) Optional() *mConnMockWrite {
	mmWrite.optional = true
	return mmWrite
}

// Expect sets up expected params for Conn.Write
func (mmWrite *mConnMockWrite) Expect(b []byte) *mConnMockWrite {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("ConnMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &ConnMockWriteExpectation{}
	}

	if mmWrite.defaultExpectation.paramPtrs != nil {
		mmWrite.mock.t.Fatalf("ConnMock.Write mock is already set by ExpectParams functions")
	}

	mmWrite.defaultExpectation.params = &ConnMockWriteParams{b}
	mmWrite.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmWrite.expectations {
		if minimock.Equal(e.params, mmWrite.defaultExpectation.params) {
			mmWrite.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWrite.defaultExpectation.params)
		}
	}

	return mmWrite
}

// ExpectBParam1 sets up expected param b for Conn.Write
func (mmWrite *mConnMockWrite) ExpectBParam1(b []byte) *mConnMockWrite {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("ConnMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &ConnMockWriteExpectation{}
	}

	if mmWrite.defaultExpectation.params != nil {
		mmWrite.mock.t.Fatalf("ConnMock.Write mock is already set by Expect")
	}

	if mmWrite.defaultExpectation.paramPtrs == nil {
		mmWrite.defaultExpectation.paramPtrs = &ConnMockWriteParamPtrs{}
	}
	mmWrite.defaultExpectation.paramPtrs.b = &b
	mmWrite.defaultExpectation.expectationOrigins.originB = minimock.CallerInfo(1)

	return mmWrite
}

// Inspect accepts an inspector function that has same arguments as the Conn.Write
func (mmWrite *mConnMockWrite) Inspect(f func(b []byte)) *mConnMockWrite {
	if mmWrite.mock.inspectFuncWrite != nil {
		mmWrite.mock.t.Fatalf("Inspect function is already set for ConnMock.Write")
	}

	mmWrite.mock.inspectFuncWrite = f

	return mmWrite
}

// Return sets up results that will be returned by Conn.Write
func (mmWrite *mConnMockWrite) Return(n int, err error) *ConnMock {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("ConnMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &ConnMockWriteExpectation{mock: mmWrite.mock}
	}
	mmWrite.defaultExpectation.results = &ConnMockWriteResults{n, err}
	mmWrite.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmWrite.mock
}

// Set uses given function f to mock the Conn.Write method
func (mmWrite *mConnMockWrite) Set(f func(b []byte) (n int, err error)) *ConnMock {
	if mmWrite.defaultExpectation != nil {
		mmWrite.mock.t.Fatalf("Default expectation is already set for the Conn.Write method")
	}

	if len(mmWrite.expectations) > 0 {
		mmWrite.mock.t.Fatalf("Some expectations are already set for the Conn.Write method")
	}

	mmWrite.mock.funcWrite = f
	mmWrite.mock.funcWriteOrigin = minimock.CallerInfo(1)
	return mmWrite.mock
}

// When sets expectation for the Conn.Write which will trigger the result defined by the following
// Then helper
func (mmWrite *mConnMockWrite) When(b []byte) *ConnMockWriteExpectation {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("ConnMock.Write mock is already set by Set")
	}

	expectation := &ConnMockWriteExpectation{
		mock:               mmWrite.mock,
		params:             &ConnMockWriteParams{b},
		expectationOrigins: ConnMockWriteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmWrite.expectations = append(mmWrite.expectations, expectation)
	return expectation
}

// Then sets up Conn.Write return parameters for the expectation previously defined by the When method
func (e *ConnMockWriteExpectation) Then(n int, err error) *ConnMock {
	e.results = &ConnMockWriteResults{n, err}
	return e.mock
}

// Times sets number of times Conn.Write should be invoked
func (mmWrite *mConnMockWrite) Times(n uint64) *mConnMockWrite {
	if n == 0 {
		mmWrite.mock.t.Fatalf("Times of ConnMock.Write mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmWrite.expectedInvocations, n)
	mmWrite.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmWrite
}

func (mmWrite *mConnMockWrite) invocationsDone() bool {
	if len(mmWrite.expectations) == 0 && mmWrite.defaultExpectation == nil && mmWrite.mock.funcWrite == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmWrite.mock.afterWriteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmWrite.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Write implements mm_net.Conn
func (mmWrite *ConnMock) Write(b []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmWrite.beforeWriteCounter, 1)
	defer mm_atomic.AddUint64(&mmWrite.afterWriteCounter, 1)

	mmWrite.t.Helper()

	if mmWrite.inspectFuncWrite != nil {
		mmWrite.inspectFuncWrite(b)
	}

	mm_params := ConnMockWriteParams{b}

	// Record call args
	mmWrite.WriteMock.mutex.Lock()
	mmWrite.WriteMock.callArgs = append(mmWrite.WriteMock.callArgs, &mm_params)
	mmWrite.WriteMock.mutex.Unlock()

	for _, e := range mmWrite.WriteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWrite.WriteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWrite.WriteMock.defaultExpectation.Counter, 1)
		mm_want := mmWrite.WriteMock.defaultExpectation.params
		mm_want_ptrs := mmWrite.WriteMock.defaultExpectation.paramPtrs

		mm_got := ConnMockWriteParams{b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmWrite.t.Errorf("ConnMock.Write got unexpected parameter b, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmWrite.WriteMock.defaultExpectation.expectationOrigins.originB, *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWrite.t.Errorf("ConnMock.Write got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmWrite.WriteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWrite.WriteMock.defaultExpectation.results
		if mm_results == nil {
			mmWrite.t.Fatal("No results are set for the ConnMock.Write")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWrite.funcWrite != nil {
		return mmWrite.funcWrite(b)
	}
	mmWrite.t.Fatalf("Unexpected call to ConnMock.Write. %v", b)
	return
}

// WriteAfterCounter returns a count of finished ConnMock.Write invocations
func (mmWrite *ConnMock) WriteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.afterWriteCounter)
}

// WriteBeforeCounter returns a count of ConnMock.Write invocations
func (mmWrite *ConnMock) WriteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.beforeWriteCounter)
}

// Calls returns a list of arguments used in each call to ConnMock.Write.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWrite *mConnMockWrite) Calls() []*ConnMockWriteParams {
	mmWrite.mutex.RLock()

	argCopy := make([]*ConnMockWriteParams, len(mmWrite.callArgs))
	copy(argCopy, mmWrite.callArgs)

	mmWrite.mutex.RUnlock()

	return argCopy
}

// MinimockWriteDone returns true if the count of the Write invocations corresponds
// the number of defined expectations
func (m *ConnMock) MinimockWriteDone() bool {
	if m.WriteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.WriteMock.invocationsDone()
}

// MinimockWriteInspect logs each unmet expectation
func (m *ConnMock) MinimockWriteInspect() {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ConnMock.Write at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterWriteCounter := mm_atomic.LoadUint64(&m.afterWriteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && afterWriteCounter < 1 {
		if m.WriteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ConnMock.Write at\n%s", m.WriteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ConnMock.Write at\n%s with params: %#v", m.WriteMock.defaultExpectation.expectationOrigins.origin, *m.WriteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && afterWriteCounter < 1 {
		m.t.Errorf("Expected call to ConnMock.Write at\n%s", m.funcWriteOrigin)
	}

	if !m.WriteMock.invocationsDone() && afterWriteCounter > 0 {
		m.t.Errorf("Expected %d calls to ConnMock.Write at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.WriteMock.expectedInvocations), m.WriteMock.expectedInvocationsOrigin, afterWriteCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConnMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockLocalAddrInspect()

			m.MinimockReadInspect()

			m.MinimockRemoteAddrInspect()

			m.MinimockSetDeadlineInspect()

			m.MinimockSetReadDeadlineInspect()

			m.MinimockSetWriteDeadlineInspect()

			m.MinimockWriteInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConnMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConnMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockLocalAddrDone() &&
		m.MinimockReadDone() &&
		m.MinimockRemoteAddrDone() &&
		m.MinimockSetDeadlineDone() &&
		m.MinimockSetReadDeadlineDone() &&
		m.MinimockSetWriteDeadlineDone() &&
		m.MinimockWriteDone()
}
