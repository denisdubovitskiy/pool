// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package pool

//go:generate minimock -i github.com/denisdubovitskiy/pool.OnCloseHook -o zzz_on_close_hook_mock_test.go -n OnCloseHookMock -p pool

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OnCloseHookMock implements OnCloseHook
type OnCloseHookMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcOnClose          func(age time.Duration, reason CloseReason, err error)
	funcOnCloseOrigin    string
	inspectFuncOnClose   func(age time.Duration, reason CloseReason, err error)
	afterOnCloseCounter  uint64
	beforeOnCloseCounter uint64
	OnCloseMock          mOnCloseHookMockOnClose
}

// NewOnCloseHookMock returns a mock for OnCloseHook
func NewOnCloseHookMock(t minimock.Tester) *OnCloseHookMock {
	m := &OnCloseHookMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.OnCloseMock = mOnCloseHookMockOnClose{mock: m}
	m.OnCloseMock.callArgs = []*OnCloseHookMockOnCloseParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOnCloseHookMockOnClose struct {
	optional           bool
	mock               *OnCloseHookMock
	defaultExpectation *OnCloseHookMockOnCloseExpectation
	expectations       []*OnCloseHookMockOnCloseExpectation

	callArgs []*OnCloseHookMockOnCloseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OnCloseHookMockOnCloseExpectation specifies expectation struct of the OnCloseHook.OnClose
type OnCloseHookMockOnCloseExpectation struct {
	mock               *OnCloseHookMock
	params             *OnCloseHookMockOnCloseParams
	paramPtrs          *OnCloseHookMockOnCloseParamPtrs
	expectationOrigins OnCloseHookMockOnCloseExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// OnCloseHookMockOnCloseParams contains parameters of the OnCloseHook.OnClose
type OnCloseHookMockOnCloseParams struct {
	age    time.Duration
	reason CloseReason
	err    error
}

// OnCloseHookMockOnCloseParamPtrs contains pointers to parameters of the OnCloseHook.OnClose
type OnCloseHookMockOnCloseParamPtrs struct {
	age    *time.Duration
	reason *CloseReason
	err    *error
}

// OnCloseHookMockOnCloseOrigins contains origins of expectations of the OnCloseHook.OnClose
type OnCloseHookMockOnCloseExpectationOrigins struct {
	origin       string
	originAge    string
	originReason string
	originErr    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOnClose *mOnCloseHookMockOnClose) Optional() *mOnCloseHookMockOnClose {
	mmOnClose.optional = true
	return mmOnClose
}

// Expect sets up expected params for OnCloseHook.OnClose
func (mmOnClose *mOnCloseHookMockOnClose) Expect(age time.Duration, reason CloseReason, err error) *mOnCloseHookMockOnClose {
	if mmOnClose.mock.funcOnClose != nil {
		mmOnClose.mock.t.Fatalf("OnCloseHookMock.OnClose mock is already set by Set")
	}

	if mmOnClose.defaultExpectation == nil {
		mmOnClose.defaultExpectation = &OnCloseHookMockOnCloseExpectation{}
	}

	if mmOnClose.defaultExpectation.paramPtrs != nil {
		mmOnClose.mock.t.Fatalf("OnCloseHookMock.OnClose mock is already set by ExpectParams functions")
	}

	mmOnClose.defaultExpectation.params = &OnCloseHookMockOnCloseParams{age, reason, err}
	mmOnClose.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOnClose.expectations {
		if minimock.Equal(e.params, mmOnClose.defaultExpectation.params) {
			mmOnClose.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnClose.defaultExpectation.params)
		}
	}

	return mmOnClose
}

// ExpectAgeParam1 sets up expected param age for OnCloseHook.OnClose
func (mmOnClose *mOnCloseHookMockOnClose) ExpectAgeParam1(age time.Duration) *mOnCloseHookMockOnClose {
	if mmOnClose.mock.funcOnClose != nil {
		mmOnClose.mock.t.Fatalf("OnCloseHookMock.OnClose mock is already set by Set")
	}

	if mmOnClose.defaultExpectation == nil {
		mmOnClose.defaultExpectation = &OnCloseHookMockOnCloseExpectation{}
	}

	if mmOnClose.defaultExpectation.params != nil {
		mmOnClose.mock.t.Fatalf("OnCloseHookMock.OnClose mock is already set by Expect")
	}

	if mmOnClose.defaultExpectation.paramPtrs == nil {
		mmOnClose.defaultExpectation.paramPtrs = &OnCloseHookMockOnCloseParamPtrs{}
	}
	mmOnClose.defaultExpectation.paramPtrs.age = &age
	mmOnClose.defaultExpectation.expectationOrigins.originAge = minimock.CallerInfo(1)

	return mmOnClose
}

// ExpectReasonParam2 sets up expected param reason for OnCloseHook.OnClose
func (mmOnClose *mOnCloseHookMockOnClose) ExpectReasonParam2(reason CloseReason) *mOnCloseHookMockOnClose {
	if mmOnClose.mock.funcOnClose != nil {
		mmOnClose.mock.t.Fatalf("OnCloseHookMock.OnClose mock is already set by Set")
	}

	if mmOnClose.defaultExpectation == nil {
		mmOnClose.defaultExpectation = &OnCloseHookMockOnCloseExpectation{}
	}

	if mmOnClose.defaultExpectation.params != nil {
		mmOnClose.mock.t.Fatalf("OnCloseHookMock.OnClose mock is already set by Expect")
	}

	if mmOnClose.defaultExpectation.paramPtrs == nil {
		mmOnClose.defaultExpectation.paramPtrs = &OnCloseHookMockOnCloseParamPtrs{}
	}
	mmOnClose.defaultExpectation.paramPtrs.reason = &reason
	mmOnClose.defaultExpectation.expectationOrigins.originReason = minimock.CallerInfo(1)

	return mmOnClose
}

// ExpectErrParam3 sets up expected param err for OnCloseHook.OnClose
func (mmOnClose *mOnCloseHookMockOnClose) ExpectErrParam3(err error) *mOnCloseHookMockOnClose {
	if mmOnClose.mock.funcOnClose != nil {
		mmOnClose.mock.t.Fatalf("OnCloseHookMock.OnClose mock is already set by Set")
	}

	if mmOnClose.defaultExpectation == nil {
		mmOnClose.defaultExpectation = &OnCloseHookMockOnCloseExpectation{}
	}

	if mmOnClose.defaultExpectation.params != nil {
		mmOnClose.mock.t.Fatalf("OnCloseHookMock.OnClose mock is already set by Expect")
	}

	if mmOnClose.defaultExpectation.paramPtrs == nil {
		mmOnClose.defaultExpectation.paramPtrs = &OnCloseHookMockOnCloseParamPtrs{}
	}
	mmOnClose.defaultExpectation.paramPtrs.err = &err
	mmOnClose.defaultExpectation.expectationOrigins.originErr = minimock.CallerInfo(1)

	return mmOnClose
}

// Inspect accepts an inspector function that has same arguments as the OnCloseHook.OnClose
func (mmOnClose *mOnCloseHookMockOnClose) Inspect(f func(age time.Duration, reason CloseReason, err error)) *mOnCloseHookMockOnClose {
	if mmOnClose.mock.inspectFuncOnClose != nil {
		mmOnClose.mock.t.Fatalf("Inspect function is already set for OnCloseHookMock.OnClose")
	}

	mmOnClose.mock.inspectFuncOnClose = f

	return mmOnClose
}

// Return sets up results that will be returned by OnCloseHook.OnClose
func (mmOnClose *mOnCloseHookMockOnClose) Return() *OnCloseHookMock {
	if mmOnClose.mock.funcOnClose != nil {
		mmOnClose.mock.t.Fatalf("OnCloseHookMock.OnClose mock is already set by Set")
	}

	if mmOnClose.defaultExpectation == nil {
		mmOnClose.defaultExpectation = &OnCloseHookMockOnCloseExpectation{mock: mmOnClose.mock}
	}

	mmOnClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOnClose.mock
}

// Set uses given function f to mock the OnCloseHook.OnClose method
func (mmOnClose *mOnCloseHookMockOnClose) Set(f func(age time.Duration, reason CloseReason, err error)) *OnCloseHookMock {
	if mmOnClose.defaultExpectation != nil {
		mmOnClose.mock.t.Fatalf("Default expectation is already set for the OnCloseHook.OnClose method")
	}

	if len(mmOnClose.expectations) > 0 {
		mmOnClose.mock.t.Fatalf("Some expectations are already set for the OnCloseHook.OnClose method")
	}

	mmOnClose.mock.funcOnClose = f
	mmOnClose.mock.funcOnCloseOrigin = minimock.CallerInfo(1)
	return mmOnClose.mock
}

// Times sets number of times OnCloseHook.OnClose should be invoked
func (mmOnClose *mOnCloseHookMockOnClose) Times(n uint64) *mOnCloseHookMockOnClose {
	if n == 0 {
		mmOnClose.mock.t.Fatalf("Times of OnCloseHookMock.OnClose mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOnClose.expectedInvocations, n)
	mmOnClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOnClose
}

func (mmOnClose *mOnCloseHookMockOnClose) invocationsDone() bool {
	if len(mmOnClose.expectations) == 0 && mmOnClose.defaultExpectation == nil && mmOnClose.mock.funcOnClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOnClose.mock.afterOnCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOnClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// OnClose implements OnCloseHook
func (mmOnClose *OnCloseHookMock) OnClose(age time.Duration, reason CloseReason, err error) {
	mm_atomic.AddUint64(&mmOnClose.beforeOnCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmOnClose.afterOnCloseCounter, 1)

	mmOnClose.t.Helper()

	if mmOnClose.inspectFuncOnClose != nil {
		mmOnClose.inspectFuncOnClose(age, reason, err)
	}

	mm_params := OnCloseHookMockOnCloseParams{age, reason, err}

	// Record call args
	mmOnClose.OnCloseMock.mutex.Lock()
	mmOnClose.OnCloseMock.callArgs = append(mmOnClose.OnCloseMock.callArgs, &mm_params)
	mmOnClose.OnCloseMock.mutex.Unlock()

	for _, e := range mmOnClose.OnCloseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmOnClose.OnCloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnClose.OnCloseMock.defaultExpectation.Counter, 1)
		mm_want := mmOnClose.OnCloseMock.defaultExpectation.params
		mm_want_ptrs := mmOnClose.OnCloseMock.defaultExpectation.paramPtrs

		mm_got := OnCloseHookMockOnCloseParams{age, reason, err}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.age != nil && !minimock.Equal(*mm_want_ptrs.age, mm_got.age) {
				mmOnClose.t.Errorf("OnCloseHookMock.OnClose got unexpected parameter age, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOnClose.OnCloseMock.defaultExpectation.expectationOrigins.originAge, *mm_want_ptrs.age, mm_got.age, minimock.Diff(*mm_want_ptrs.age, mm_got.age))
			}

			if mm_want_ptrs.reason != nil && !minimock.Equal(*mm_want_ptrs.reason, mm_got.reason) {
				mmOnClose.t.Errorf("OnCloseHookMock.OnClose got unexpected parameter reason, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOnClose.OnCloseMock.defaultExpectation.expectationOrigins.originReason, *mm_want_ptrs.reason, mm_got.reason, minimock.Diff(*mm_want_ptrs.reason, mm_got.reason))
			}

			if mm_want_ptrs.err != nil && !minimock.Equal(*mm_want_ptrs.err, mm_got.err) {
				mmOnClose.t.Errorf("OnCloseHookMock.OnClose got unexpected parameter err, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOnClose.OnCloseMock.defaultExpectation.expectationOrigins.originErr, *mm_want_ptrs.err, mm_got.err, minimock.Diff(*mm_want_ptrs.err, mm_got.err))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOnClose.t.Errorf("OnCloseHookMock.OnClose got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOnClose.OnCloseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmOnClose.funcOnClose != nil {
		mmOnClose.funcOnClose(age, reason, err)
		return
	}
	mmOnClose.t.Fatalf("Unexpected call to OnCloseHookMock.OnClose. %v %v %v", age, reason, err)

}

// OnCloseAfterCounter returns a count of finished OnCloseHookMock.OnClose invocations
func (mmOnClose *OnCloseHookMock) OnCloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnClose.afterOnCloseCounter)
}

// OnCloseBeforeCounter returns a count of OnCloseHookMock.OnClose invocations
func (mmOnClose *OnCloseHookMock) OnCloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnClose.beforeOnCloseCounter)
}

// Calls returns a list of arguments used in each call to OnCloseHookMock.OnClose.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnClose *mOnCloseHookMockOnClose) Calls() []*OnCloseHookMockOnCloseParams {
	mmOnClose.mutex.RLock()

	argCopy := make([]*OnCloseHookMockOnCloseParams, len(mmOnClose.callArgs))
	copy(argCopy, mmOnClose.callArgs)

	mmOnClose.mutex.RUnlock()

	return argCopy
}

// MinimockOnCloseDone returns true if the count of the OnClose invocations corresponds
// the number of defined expectations
func (m *OnCloseHookMock) MinimockOnCloseDone() bool {
	if m.OnCloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OnCloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OnCloseMock.invocationsDone()
}

// MinimockOnCloseInspect logs each unmet expectation
func (m *OnCloseHookMock) MinimockOnCloseInspect() {
	for _, e := range m.OnCloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OnCloseHookMock.OnClose at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOnCloseCounter := mm_atomic.LoadUint64(&m.afterOnCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OnCloseMock.defaultExpectation != nil && afterOnCloseCounter < 1 {
		if m.OnCloseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OnCloseHookMock.OnClose at\n%s", m.OnCloseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OnCloseHookMock.OnClose at\n%s with params: %#v", m.OnCloseMock.defaultExpectation.expectationOrigins.origin, *m.OnCloseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnClose != nil && afterOnCloseCounter < 1 {
		m.t.Errorf("Expected call to OnCloseHookMock.OnClose at\n%s", m.funcOnCloseOrigin)
	}

	if !m.OnCloseMock.invocationsDone() && afterOnCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to OnCloseHookMock.OnClose at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OnCloseMock.expectedInvocations), m.OnCloseMock.expectedInvocationsOrigin, afterOnCloseCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OnCloseHookMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockOnCloseInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OnCloseHookMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OnCloseHookMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockOnCloseDone()
}
